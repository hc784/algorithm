#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;

int S[500],n,cache[500]; // 캐쉬에는 배열 위치에 해당하는 값에서 시작했을 때 가장 긴 값을 저장.


/* 맥스값을 저장하고 뒤에 남은 수가 맥스값보다 작을 경우에 반복을 멈춤.
그리고 recur은 그냥 반복문으로 해도 상관없을 거 같은데?

*/
int MaxSize(int index,int count,int lastIndex)
{
    int& ret = cache[index];
    if(index==n)
        return count;
    
    if(S[lastIndex]<S[index]) // 배열에 기록된 부분수열의 마지막 수보다 수열의 인덱스에 잇는 값이 더 크다면 부분 수열에 그 값을 넣어야할까? 
    // 굳이 넣을 필요없이 그냥 마지막 인덱스 값만 저장하고 그 값이랑 비교하면서 길이만 기록하면 됨. 
    // 그리고 캐쉬에는 스킵할 인덱스를 저장하면 되나? 전체수열이랑 같은 길이의 캐쉬를 만들고 만약 전체수열에 어떤 값이 부분수열로 만들어졌을경우 
    // 그 만들어진 인덱스에 해당하는 캐쉬의 수를 변환해야함. 변환하는 값은 거기서 부터의 길이.
    {
         // 이건 길이에 지금 인덱스 값을 포함하지 않은 경우
        if(ret!=-1)
        {
            return max(MaxSize(index+1,count,lastIndex),ret+count);
        }
        int temp = MaxSize(index+1,count+1,index);
        ret = temp - count;  
        return max(MaxSize(index+1,count,lastIndex),temp);
    } 
    else
    {
        return MaxSize(index+1,count,lastIndex);
    }
} 


int recur()
{// 현재 인덱스에 있는 수가 이미 증가 부분 수열에 포함된 적이 있었다면 다음 숫자로 넘어가야함. 즉 포함된적 없던 수만 검증하기 5 6 7 8 3 2 1 2 3 4 5 6
    
    // if(ret != -1)
    // {
    //     recur(index+1);
    // }
    
    // else if(S[index+1]>S[index]) // 다음 수가 지금 수보다 클 경우 길이를 구해야함. 1번 과정으로 길이 구하기. 길이 구하는 과정에서 캐쉬에 각 인덱스마다 길이 저장.
    // {
    //     MaxSize(index,1,index);// 현재 인덱스에서 최대 길이를 구함 
    //     recur(index+1);
    //     // 다음 수가 작아지는 상황에서 더 큰수가 더 길어지는 상황이 있을까? - - 없음 
    //     //100 50 30 101 102 103
    // }
    // else
    // {
    //     recur(index+1);
    // }
    int maxLength=0;
    for(int i=0; n-i>maxLength ; i++) // n - i > maxLength 나중에 검증해보기
    {
        int& ret = cache[i]; 
        if(ret != -1)
            continue;
        if(S[i+1]>S[i])
            maxLength=max(MaxSize(i,1,i),maxLength);
    }
    return maxLength;
    
    // 다음 수가 지금 수보다 같거나 작을 경우에는 다음 인덱스로 재귀
}
/* 캐쉬의 사용법?
maxsize에서 사용하는 경우는 이미 계산한 적이 있을 때 이후에 구해지는 길이는 같음. 이전에 구했던 길이는 다를 수 있으나. 
recur에서 사용하는 경우는 나중에 생각해보자

수열의 마지막에 갔을 때 count+1은 어떻게 처리가 될까?
count+1 을 넘겨주는 시점이 현재 갯수 즉 다음 재귀에서는 처리가 안되네. 그래서 ++count를 해줘야 return으로 밖에 나왓을때 현재 길이가 맞는구나. 
5 - 3 + 1  = 3 
+ 1 을 해줘야 길이가 맞음 또는 3-1 

내가 지금 하고 싶은거 count를 세면서 올라가는게 아니라 내려오면서 길이 계산하는 것.
그러려면 마지막 값에 갔을 때 리턴을 하게 되는데, 저기 maxSize 두개중에 비교를 해서 하나만 리턴할 방법이 없는 거 같구나. 그리고 
캐쉬에 저장할 값은 현재 인덱스를 포함했을 때 이후 경우의 수에서 가장 큰 값을 저장해야함. 
pair로 두 길이를 저장해서 가지고 다녀야하나..
이건 그냥 count로 길이를 세는게 더 효율적일듯
그리고 길이를 max 길이를 반환하는데... 이 길이는 포함했는지 안했는지 모르는 길이네.................. 
포함 된 적 있는지 없는지만 판단해도 상관없을까? 
길이는 안넣어도 되려나?
꼭 넣어야하는데 이건.

길이를 계산하는 방법
지금 코딩한 대로라면,, 마지막에 가서 return 하면서 가장 큰 count를 반환하는게 끝임. 
그렇게 되면 캐쉬에 길이를 넣을 수 없음.

캐쉬에 길이를 넣으려면 count를 지우고 길이를 끝에서부터 계산해야함.
이렇게 코딩하기 위해서는 여기서는 count 1이 증가한다는 것을 표시해야하는데
그걸 표시하는 방법이 뭘까?
캐쉬에 들어가는 값은 무조건 포함한 경우에만 값이 들어가게 됨 
즉 다른 재귀 두개는 캐쉬에 값이 들어가지 않음 !! 
나머지는 

이 부분은 한 숫자 안에서 많은 경우의 수를 나누는 과정

        // 지금 수에서 길이가 몇인지 검증해야함. 검증하기 위해서는? 작은 수는 스킵하고 큰수만 확인하면서 모든 수열을
        // 탐색해서 길이를 확잉해야함. 만약 큰수를 만난다면 count++ 작은수는 다음 반복으로 컨티뉴.
        //이렇게 해서 최종적으로 길이를 구함. 이렇게 구한 길이를 캐쉬에 저장하나? 아니지 각 반복마다 숫자가 있을텐데. 
        count++을 한 수, 즉 지금 수보다 큰 수를 만났을 경우에는 캐쉬에 길이를 저장해야함. 그럼 이걸 반복문이 아니라 재귀로 하는게 맞을까?
        재귀로 해서 재귀 나올때마다 반환값은 길이로 하고, 들어가는 인수는 길이와 인덱스. 이 반복문을 재귀로 나타내고, 그리고 다른 검증 재귀를 하나 더 만들어서
        총 재귀를 두개를 사용하기?
        
        오류
        같은 수가 나오면 어떡해?
        앞에서 이미 더 큰 길이의 값이 캐쉬에 들어가 있는데 뒤에서 같은 숫자가 나오면 더 큰 숫자가 들어가게 됨.
        그리고 수를 10만개 다 일일이 저장해봤자 의미가 없는 거같은데?
        그냥 수열의 위치로 저장하는게 맞을까?
        근데 같은 숫자가 나왓을때는 어떡해?
        그리고 이미 검증된 수보다 큰 수는 항상 더 작지는 않구나 1 1000 456789 그리고 이건 1 456789가 1 1000보다 훨씬 기네.
        이건 나중에 생각해보자.
        와일드카드랑 비슷하게 가야할까?
        모든 부분수열을 할필요는 없지만 1 1000과 1 4를 둘다 해봐야하는건 맞구나. 
        코드를 다시 짜야할듯.
        ## 1에서 모든 경우를 확인해야 하는게 맞음. 근데 생략되는 경우가 밑에 검증 과정이랑 같음. 
        따라서 검사 결과는 많지 않다.
        이미 부분 수열로 만들어진 수는 다시 부분수열에 들어갈 필요가 없다. 부분수열에 들어가지 않은 수만 검사하면 된다.
        그리고 앞에서 나온 수로도 할 필요가 있나? 다시할 필요가 있다.
        31 1 15 30 45 15 16 17 18 50 
        
        
        다시 콘티. 2번 과정으로 일단 가장 길게 만들어 질 수 있는 숫자를 찾고 그 숫자 안에서 경우의 수를 나누며 1번 과정으로 최대 길이를 찾음.
        */
        
/* 이 부분은 앞글자를 버리고 다음 글자로 넘어가는 과정

54321678
정수를 만나면 그 정수로 시작
이미 연속된 수로는 즉 반복문으로 연속수열에 들어간 수는 시작으로 다시 확인할 필요가 없다.
작은 수가 연속된다면? 일단 그 작은 수는 항상 앞에 있는 큰 수보다 길이가 클 수 밖에 없다. 즉 가장 앞에 있는 수로는 확인해볼 필요가 없다.
앞에 있는 수보다 작은수가 연속으로 나타난다면 연속된 작은 수중 가장 뒤에 있는 수로 길이를 확인한다.
그 앞은 스킵한다.
같은 수가 연속된다면 뒤에 있는 같은 숫자로 길이를 확인한다. 앞이든 뒤는 길이는 같다. 
앞에서 했던 수와 같은 수가 연속 되지는 않지만 뒤에 있다면 다시 확인할 필요가 없다. 항상 앞에 같은 수 보다 짧다.

결론은? 큰 수가 연속 될때만 길이 확인을 하는 것인가?

검증
작은수가 연속될때는 가장 뒤에 있는 작은 수로 검증
같은수가 연속 될때는 뒤에 수로 검증 

검증 결과 true

추가적인 적용 사항
증가 부분 수열에 한번이라도 들어간 수는 검증하지 않음. 스킵
앞에서 검증 했던 수가 뒤에 나온다면 검증하지 검증하지 않음. 스킵

코드 콘티

앞에서 검증했던 증가 부분 수열에 들어간 수 전부를 배열에 기록함.
검증했던 수보다 큰 수는 전부 배열에 기록됨. 즉 다시 검증할 일이 없음. 같은 수도 마찬가지 
*** 여기서 miss 큰 수 같은수 전부가 기록 되지 않음. 기록 되지 않는 경우가 있음. 그 수는 검증을 해야함.

작은수만 검증하게 됨.
작은 수는 다시 검증이 필요함. 
작은수를 검증할 때는 배열에 기록된 수와는 상관없음 큰 수는 전부 넣음.
작은 수와 뒤에 연결되는 수열들 모두를 이전 배열에 그대로 다시 기록. @@ 여기서 살짝 고치면 효율 높일 수 있을까? 
## 이전 배열에 다시 기록할때 겹치는 부분이 있다면 거기서 기록을 멈추고 배열에 들어있는 수만큼 길이를 덧붙이기? ## - 메모이제이션
캐쉬에 해당하는 숫자의 뒷 길이를 저장함.$$

콘티 끝 

*/
int main()
{
    int caseNum;
    cin>>caseNum;  
    vector<int> ret(0);
    while(caseNum--)
    {
        cin>>n;
        
        for(int i=0;i<n;i++)
        {
            cin>>S[i];
        }
        memset(cache,-1,sizeof(cache));
        ret.push_back(recur());
    }
    for(int k : ret)
    {
        cout<<k<<endl;
    }
 
    return 0;
}

